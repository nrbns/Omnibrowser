{"version":3,"file":"ipc-events-B-mtt1te.js","sources":["../../src/lib/ipc-events.ts"],"sourcesContent":["/**\r\n * Real-time IPC Event System\r\n * Typed event listeners for live updates from main process\r\n */\r\n\r\n// @ts-nocheck\r\n\r\n\r\nexport interface TabUpdate {\r\n  id: string;\r\n  title: string;\r\n  url: string;\r\n  active: boolean;\r\n  favicon?: string;\r\n  progress?: number;\r\n  isLoading?: boolean;\r\n  mode?: 'normal' | 'ghost' | 'private';\r\n  containerId?: string;\r\n  containerName?: string;\r\n  containerColor?: string;\r\n  createdAt?: number;\r\n  lastActiveAt?: number;\r\n  sessionId?: string;\r\n  profileId?: string;\r\n}\r\n\r\nexport interface ContainerInfo {\r\n  id: string;\r\n  name: string;\r\n  color: string;\r\n  icon?: string;\r\n  description?: string;\r\n  scope?: 'global' | 'session' | 'ephemeral';\r\n  persistent?: boolean;\r\n  system?: boolean;\r\n}\r\n\r\nexport type ProfileKind = 'default' | 'work' | 'personal' | 'custom';\r\n\r\nexport interface ProfilePolicy {\r\n  allowDownloads: boolean;\r\n  allowPrivateWindows: boolean;\r\n  allowGhostTabs: boolean;\r\n  allowScreenshots: boolean;\r\n  allowClipping: boolean;\r\n}\r\n\r\nexport interface ProfileInfo {\r\n  id: string;\r\n  name: string;\r\n  color?: string;\r\n  kind?: ProfileKind;\r\n  system?: boolean;\r\n  policy?: ProfilePolicy;\r\n  description?: string;\r\n}\r\n\r\nexport type ProfilePolicyAction = 'downloads' | 'private-window' | 'ghost-tab' | 'screenshot' | 'clip';\r\n\r\nexport interface ProfilePolicyBlockedEvent {\r\n  profileId: string;\r\n  action: ProfilePolicyAction;\r\n}\r\n\r\nexport interface ShieldsCounters {\r\n  tabId: string;\r\n  ads: number;\r\n  trackers: number;\r\n  httpsUpgrades: number;\r\n  cookiesBlocked: number;\r\n}\r\n\r\nexport interface NetworkStatus {\r\n  proxy?: {\r\n    enabled: boolean;\r\n    type: 'socks5' | 'http' | 'tor';\r\n    host?: string;\r\n  };\r\n  tor?: {\r\n    enabled: boolean;\r\n    circuitEstablished: boolean;\r\n    identity: string;\r\n  };\r\n  vpn?: {\r\n    enabled: boolean;\r\n    connected: boolean;\r\n    provider?: string;\r\n  };\r\n  doh?: {\r\n    enabled: boolean;\r\n    provider: string;\r\n  };\r\n}\r\n\r\nexport interface PageWatcher {\r\n  id: string;\r\n  url: string;\r\n  createdAt: number;\r\n  intervalMinutes: number;\r\n  lastCheckedAt?: number;\r\n  lastHash?: string;\r\n  lastChangeAt?: number;\r\n  status: 'idle' | 'checking' | 'changed' | 'error';\r\n  error?: string;\r\n}\r\n\r\nexport interface DownloadUpdate {\r\n  id: string;\r\n  url: string;\r\n  filename: string;\r\n  status: 'pending' | 'downloading' | 'completed' | 'failed' | 'cancelled' | 'in-progress' | 'blocked';\r\n  progress?: number;\r\n  receivedBytes?: number;\r\n  totalBytes?: number;\r\n  path?: string;\r\n  checksum?: string;\r\n  createdAt?: number;\r\n  speedBytesPerSec?: number;\r\n  etaSeconds?: number;\r\n  safety?: {\r\n    status: 'pending' | 'clean' | 'warning' | 'blocked' | 'unknown';\r\n    threatLevel?: 'low' | 'medium' | 'high' | 'critical';\r\n    details?: string;\r\n    recommendations?: string[];\r\n    scannedAt?: number;\r\n    quarantinePath?: string;\r\n  };\r\n}\r\n\r\nexport interface AgentStep {\r\n  taskId: string;\r\n  stepId: string;\r\n  type: 'plan' | 'tool' | 'log' | 'result';\r\n  content: string;\r\n  timestamp: number;\r\n}\r\n\r\nexport interface AgentPlan {\r\n  taskId: string;\r\n  steps: Array<{ id: string; description: string; tool?: string }>;\r\n  budget: { tokens: number; seconds: number; requests: number };\r\n  remaining: { tokens: number; seconds: number; requests: number };\r\n}\r\n\r\nexport interface PermissionRequest {\r\n  id: string;\r\n  origin: string;\r\n  permission: 'camera' | 'microphone' | 'filesystem' | 'notifications';\r\n  callback: (granted: boolean, remember?: boolean) => void;\r\n}\r\n\r\nexport interface ConsentRequest {\r\n  id: string;\r\n  action: {\r\n    type: string;\r\n    description: string;\r\n    risk: 'low' | 'medium' | 'high';\r\n  };\r\n  callback: (approved: boolean) => void;\r\n}\r\n\r\nexport interface TabNavigationState {\r\n  tabId: string;\r\n  canGoBack: boolean;\r\n  canGoForward: boolean;\r\n}\r\n\r\nexport interface EfficiencyModeEvent {\r\n  mode: 'normal' | 'battery-saver' | 'extreme';\r\n  label?: string | null;\r\n  badge?: string | null;\r\n  timestamp: number;\r\n  snapshot: {\r\n    batteryPct: number | null;\r\n    charging: boolean | null;\r\n    ramMb: number;\r\n    cpuLoad1: number;\r\n    activeTabs: number;\r\n    carbonIntensity?: number | null;\r\n    carbonRegion?: string | null;\r\n  };\r\n}\r\n\r\nexport interface EfficiencyAlertAction {\r\n  id: string;\r\n  label: string;\r\n  type: 'mode' | 'hibernate';\r\n  mode?: 'normal' | 'battery-saver' | 'extreme';\r\n}\r\n\r\nexport interface EfficiencyAlert {\r\n  id: string;\r\n  severity: 'info' | 'warning' | 'critical';\r\n  title: string;\r\n  message: string;\r\n  timestamp: number;\r\n  actions: EfficiencyAlertAction[];\r\n}\r\n\r\nexport interface ShadowVisitedEntry {\r\n  url: string;\r\n  title: string;\r\n  firstSeen: number;\r\n}\r\n\r\nexport interface ShadowSessionSummaryEvent {\r\n  sessionId: string;\r\n  persona?: string;\r\n  startedAt: number;\r\n  endedAt: number;\r\n  durationMs: number;\r\n  totalVisits: number;\r\n  uniqueHosts: number;\r\n  visited: ShadowVisitedEntry[];\r\n  recommendations: string[];\r\n}\r\n\r\nexport interface ShadowSessionEndedEvent {\r\n  sessionId: string;\r\n  summary: ShadowSessionSummaryEvent | null;\r\n}\r\n\r\nexport interface PrivacyAuditSummary {\r\n  score: number;\r\n  grade: 'low' | 'moderate' | 'high';\r\n  trackers: Array<{ host: string; count: number }>;\r\n  thirdPartyHosts: Array<{ host: string; count: number }>;\r\n  message: string;\r\n  suggestions: string[];\r\n  timestamp: number;\r\n  ai?: {\r\n    riskScore: number;\r\n    riskLevel: 'low' | 'medium' | 'high';\r\n    summary: string;\r\n    actions: string[];\r\n    issues: Array<{ category: string; detail: string; severity: 'low' | 'medium' | 'high' }>;\r\n    generatedAt?: string;\r\n  } | null;\r\n}\r\n\r\n// Event bus for renderer-side state management\r\nclass IPCEventBus {\r\n  private listeners = new Map<string, Set<(data: any) => void>>();\r\n  private ipcListeners = new Map<string, WeakSet<(data: any) => void>>(); // Use WeakSet to track IPC listeners\r\n  private customEventHandlers = new Map<string, WeakMap<(data: any) => void, EventListener>>(); // Use WeakMap for custom handlers\r\n  private registeredChannels = new Set<string>(); // Track which IPC channels we've registered globally\r\n  private ipcHandlers = new Map<string, (event: any, data: any) => void>(); // Store IPC handlers in a Map instead of on window.ipc\r\n\r\n  on<T>(event: string, callback: (data: T) => void): () => void {\r\n    if (!this.listeners.has(event)) {\r\n      this.listeners.set(event, new Set());\r\n    }\r\n    this.listeners.get(event)!.add(callback);\r\n\r\n    // Subscribe to IPC channel if window.ipc exists (only once per event channel)\r\n    if (window.ipc && (window.ipc as any).on) {\r\n      if (!this.ipcListeners.has(event)) {\r\n        this.ipcListeners.set(event, new WeakSet());\r\n      }\r\n      const ipcCallbacks = this.ipcListeners.get(event)!;\r\n      \r\n      // Only register the channel once globally, not per callback\r\n      if (!this.registeredChannels.has(event)) {\r\n        this.registeredChannels.add(event);\r\n        const globalHandler = (_event: any, data: any) => {\r\n          // Emit to all listeners for this event\r\n          const callbacks = this.listeners.get(event);\r\n          if (callbacks) {\r\n            const eventData = data || _event;\r\n            callbacks.forEach(cb => {\r\n              try {\r\n                cb(eventData);\r\n              } catch (error) {\r\n                console.error(`Error in IPC event handler for ${event}:`, error);\r\n              }\r\n            });\r\n          }\r\n        };\r\n        (window.ipc as any).on(event, globalHandler);\r\n        // Store the handler in our Map instead of on window.ipc\r\n        this.ipcHandlers.set(event, globalHandler);\r\n      }\r\n      \r\n      // Track this callback (using WeakSet, so it's automatically cleaned up)\r\n      ipcCallbacks.add(callback);\r\n    }\r\n\r\n    // Also listen for custom events (only once per callback)\r\n    if (!this.customEventHandlers.has(event)) {\r\n      this.customEventHandlers.set(event, new WeakMap());\r\n    }\r\n    const customHandlers = this.customEventHandlers.get(event)!;\r\n    if (!customHandlers.has(callback)) {\r\n      const handler = (e: CustomEvent) => {\r\n        try {\r\n          callback(e.detail);\r\n        } catch (error) {\r\n          console.error(`Error in custom event handler for ${event}:`, error);\r\n        }\r\n      };\r\n      customHandlers.set(callback, handler);\r\n      window.addEventListener(event, handler as EventListener);\r\n    }\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n      this.listeners.get(event)?.delete(callback);\r\n      \r\n      // Remove custom event listener\r\n      const customHandlers = this.customEventHandlers.get(event);\r\n      if (customHandlers?.has(callback)) {\r\n        const handler = customHandlers.get(callback);\r\n        if (handler) {\r\n          window.removeEventListener(event, handler as EventListener);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  emit(event: string, data: any) {\r\n    window.dispatchEvent(new CustomEvent(event, { detail: data }));\r\n  }\r\n\r\n  off(event: string, callback: (data: any) => void) {\r\n    this.listeners.get(event)?.delete(callback);\r\n    // Note: IPC listeners are managed globally, not per-callback\r\n    // They will be cleaned up when the channel is no longer needed\r\n  }\r\n  \r\n  // Cleanup all listeners for an event (call when component unmounts or event is no longer needed)\r\n  removeAllListeners(event: string) {\r\n    this.listeners.delete(event);\r\n    this.ipcListeners.delete(event);\r\n    this.customEventHandlers.delete(event);\r\n    this.registeredChannels.delete(event);\r\n    \r\n    // Remove global IPC handler if it exists\r\n    if (window.ipc && (window.ipc as any).removeListener) {\r\n      const handler = this.ipcHandlers.get(event);\r\n      if (handler) {\r\n        (window.ipc as any).removeListener(event, handler);\r\n        this.ipcHandlers.delete(event);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport const ipcEvents = new IPCEventBus();\r\n\r\n// Subscribe to typed IPC channels\r\nif (typeof window !== 'undefined') {\r\n  // Listen for tab updates\r\n  if (window.ipc && (window.ipc as any).on) {\r\n    const tabUpdateHandler = (_event: any, tabs: any) => {\r\n      // Handle both direct data and event+data formats\r\n      const tabList = Array.isArray(tabs) ? tabs : (Array.isArray(_event) ? _event : []);\r\n      ipcEvents.emit('tabs:updated', tabList);\r\n    };\r\n    const tabProgressHandler = (_event: any, data: any) => {\r\n      const progressData = data || _event;\r\n      ipcEvents.emit('tabs:progress', progressData);\r\n    };\r\n    const navigationStateHandler = (_event: any, data: any) => {\r\n      const navData = data || _event;\r\n      ipcEvents.emit('tabs:navigation-state', navData);\r\n    };\r\n\r\n    // Listen to both legacy and typed IPC channels\r\n    (window.ipc as any).on('tabs:updated', tabUpdateHandler);\r\n    (window.ipc as any).on('ob://ipc/v1/tabs:updated', tabUpdateHandler);\r\n    (window.ipc as any).on('tabs:progress', tabProgressHandler);\r\n    (window.ipc as any).on('ob://ipc/v1/tabs:progress', tabProgressHandler);\r\n    (window.ipc as any).on('tabs:navigation-state', navigationStateHandler);\r\n    (window.ipc as any).on('ob://ipc/v1/tabs:navigation-state', navigationStateHandler);\r\n\r\n    // Proper cleanup using Page Lifecycle API instead of unload\r\n    const cleanup = () => {\r\n      if (window.ipc && (window.ipc as any).removeListener) {\r\n        (window.ipc as any).removeListener('tabs:updated', tabUpdateHandler);\r\n        (window.ipc as any).removeListener('ob://ipc/v1/tabs:updated', tabUpdateHandler);\r\n        (window.ipc as any).removeListener('tabs:progress', tabProgressHandler);\r\n        (window.ipc as any).removeListener('ob://ipc/v1/tabs:progress', tabProgressHandler);\r\n        (window.ipc as any).removeListener('tabs:navigation-state', navigationStateHandler);\r\n        (window.ipc as any).removeListener('ob://ipc/v1/tabs:navigation-state', navigationStateHandler);\r\n      }\r\n    };\r\n\r\n    // Use pagehide event (modern alternative to unload)\r\n    if ('onpagehide' in window) {\r\n      window.addEventListener('pagehide', cleanup);\r\n    }\r\n    // Fallback for browsers that don't support pagehide\r\n    if (typeof document !== 'undefined' && 'visibilityState' in document) {\r\n      const handleVisibilityChange = () => {\r\n        if (document.visibilityState === 'hidden') {\r\n          // Don't cleanup on visibility change, only on actual page unload\r\n        }\r\n      };\r\n      document.addEventListener('visibilitychange', handleVisibilityChange);\r\n    }\r\n  }\r\n\r\n  // Listen for shields counters\r\n  window.addEventListener('shields:counters', ((e: CustomEvent<ShieldsCounters>) => {\r\n    ipcEvents.emit('shields:counters', e.detail);\r\n  }) as EventListener);\r\n\r\n  // Listen for network status\r\n  window.addEventListener('net:status', ((e: CustomEvent<NetworkStatus>) => {\r\n    ipcEvents.emit('net:status', e.detail);\r\n  }) as EventListener);\r\n\r\n  // Listen for downloads\r\n  window.addEventListener('downloads:started', ((e: CustomEvent<DownloadUpdate>) => {\r\n    ipcEvents.emit('downloads:started', e.detail);\r\n  }) as EventListener);\r\n  window.addEventListener('downloads:progress', ((e: CustomEvent<DownloadUpdate>) => {\r\n    ipcEvents.emit('downloads:progress', e.detail);\r\n  }) as EventListener);\r\n  window.addEventListener('downloads:done', ((e: CustomEvent<DownloadUpdate>) => {\r\n    ipcEvents.emit('downloads:done', e.detail);\r\n  }) as EventListener);\r\n\r\n  // Listen for agent events\r\n  window.addEventListener('agent:plan', ((e: CustomEvent<AgentPlan>) => {\r\n    ipcEvents.emit('agent:plan', e.detail);\r\n  }) as EventListener);\r\n  window.addEventListener('agent:step', ((e: CustomEvent<AgentStep>) => {\r\n    ipcEvents.emit('agent:step', e.detail);\r\n  }) as EventListener);\r\n  window.addEventListener('agent:log', ((e: CustomEvent<AgentStep>) => {\r\n    ipcEvents.emit('agent:log', e.detail);\r\n  }) as EventListener);\r\n  window.addEventListener('agent:consent:request', ((e: CustomEvent<ConsentRequest>) => {\r\n    ipcEvents.emit('agent:consent:request', e.detail);\r\n  }) as EventListener);\r\n\r\n  // Listen for streaming AI events via IPC\r\n  if (window.ipc && (window.ipc as any).on) {\r\n    (window.ipc as any).on('agent:stream:chunk', (_event: any, data: any) => {\r\n      ipcEvents.emit('agent:stream:chunk', data);\r\n    });\r\n    (window.ipc as any).on('agent:stream:done', (_event: any, data: any) => {\r\n      ipcEvents.emit('agent:stream:done', data);\r\n    });\r\n    (window.ipc as any).on('agent:stream:error', (_event: any, data: any) => {\r\n      ipcEvents.emit('agent:stream:error', data);\r\n    });\r\n  }\r\n\r\n  // Listen for permission requests\r\n  window.addEventListener('permissions:request', ((e: CustomEvent<PermissionRequest>) => {\r\n    ipcEvents.emit('permissions:request', e.detail);\r\n  }) as EventListener);\r\n\r\n  // Listen for fullscreen changes\r\n  window.addEventListener('app:fullscreen-changed', ((e: CustomEvent<{ fullscreen: boolean }>) => {\r\n    ipcEvents.emit('app:fullscreen-changed', e.detail);\r\n  }) as EventListener);\r\n\r\n  // Also listen via IPC if available\r\n  if (window.ipc && (window.ipc as any).on) {\r\n    const fullscreenHandler = (data: { fullscreen: boolean }) => {\r\n      ipcEvents.emit('app:fullscreen-changed', data);\r\n    };\r\n    (window.ipc as any).on('app:fullscreen-changed', fullscreenHandler);\r\n    \r\n    // Cleanup handler for fullscreen events\r\n    const cleanupFullscreen = () => {\r\n      if (window.ipc && (window.ipc as any).removeListener) {\r\n        (window.ipc as any).removeListener('app:fullscreen-changed', fullscreenHandler);\r\n      }\r\n    };\r\n    \r\n    // Use pagehide for cleanup (modern alternative to unload)\r\n    if ('onpagehide' in window) {\r\n      window.addEventListener('pagehide', cleanupFullscreen, { once: true });\r\n    }\r\n  }\r\n}\r\n\r\n// React hooks for easy component integration\r\n// Note: This hook must be imported and used in React components\r\n// The actual hook implementation is in a separate file to avoid require() in browser\r\n\r\n"],"names":["IPCEventBus","event","callback","ipcCallbacks","globalHandler","_event","data","callbacks","eventData","cb","error","customHandlers","handler","e","ipcEvents","tabUpdateHandler","tabs","tabList","tabProgressHandler","progressData","navigationStateHandler","navData","cleanup","handleVisibilityChange","fullscreenHandler","cleanupFullscreen"],"mappings":"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"}